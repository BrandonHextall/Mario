<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactible Entities</title>
    <style>canvas {border:1px solid;position:fixed;left:10}</style>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
    <script src="./tilemaps.js"></script>
</head>
<body>
    <!-- Make a 2048 game -->
    <!-- Make Tetris game -->
    <!--
        Permanent comments (for guidance and descriptions of code) don't have whitespace after //, as well as starting with a capital letter
        Temporary comments (telling me what I need to make) has a whitespace after //, as well as starting with no capital
        commented code (whether temporarily for debugging purposes or failed code or otherwise) is the same as temporary. distinguishing between the two should be easy enough
        
        When making classes, have a list or something similar for the assets and colour schemes etc so that they dont have to be hardcoded
        green enemies have the same colour palette underwater and in castle
        fire assets come under red enemy class
        When making classes for objects, create an attribute defining the location of the colour palette for that object
        
        When rendering tiles, will need to clear a rectangle of the tilemap, draw the background over it again,
        then draw the asset
        This is because in the original game, when tiles overlap parts of the initial asset get destroyed where
        the new asset as been drawn and do not overlap.
        I assume coins and items do not replace other sprites

        When spawning enemies, give the enemy a spawning block (indicated on the level maps) and when that pillar of tiles is rendered, activate the enemy

        game screen ratio is 4:3.
        This might help with side scrolling stuff: https://gamedev.stackexchange.com/questions/19104/how-do-i-implement-side-scrolling-in-a-javascript-platformer

        do everything without tilesize and scaling cuz when thats done, everything will scale easily

        when picking up a coin, check if coins = 100. if yes reset to 0 and give extra life

        when mario hieadbutts a tile, change the y-velocity to an immediate negative value or immediately invert the y-velocity

        NEXT TASK:
            Fix mushroom bounce

            Create rest of powerups (flower, star)
            
            make mario crouch:
                x-acceleration = 0 while crouched
                change hitbox and sprite
                can still jump
                if mario small, cannot crouch, no attributes affected by down button
    -->
    <h2 id="debug"></h2>
    <canvas id="canvas"></canvas>
    <script>
        //for extending classes, the child class can use "super()" to inherit an attribute from the parent class
        //calling the child class also uses the parent class attributes when called
        //apparently functions are immediately inherited from parent class. good to know
        //when drawing stuff, gonna need to draw it from the bottom left as mario can shrink and grow, and enemies can get bigger and smaller
        /*
            all things done using coordinates of entities will need to be done from the bottom left of the entityHitbox.
            Essentially, all stuff that uses coordinates should be done opposite
        */
        let Game = {}, tileSize = 2;
        //may also want to consider doing the individual side check for entities as it may work better
        const   sprites = array,
                getId = (what)  => {return document.getElementById(what)},
                canvasElem = getId('canvas'),
                canvas = canvasElem.getContext('2d'),
                debug = getId("debug");
                canvasElem.focus();

        //for now, use only the original resolution of 256 x 240 then scale everything
        Game.setResolution = () => {
            let originalGameWidth = 256, originalGameHeight = 240,
                screenWidth = window.innerWidth, screenHeight = window.innerHeight,
                resolutionMultiplier;
            resolutionMultiplier = (screenWidth < screenHeight ? screenWidth : screenHeight) / originalGameWidth;
            //tileSize = resolutionMultiplier;
            tileSize = 1;
            //canvasElem.setAttribute("width", originalGameWidth * resolutionMultiplier);
            //canvasElem.setAttribute("height", originalGameHeight * resolutionMultiplier);
            //this will be the game size after physics are completed until the game in general is finished, which then I will make the sizing dynamic
            canvasElem.setAttribute("width", 256);
            canvasElem.setAttribute("height", 240);
            //game size to attempt to sort physics
            canvasElem.setAttribute("width", 450);
            canvasElem.setAttribute("height", 400);
        };
        Game.worlds = [];
        Game.currentLevel = 1;
        Game.currentWorld = 1;
        Game.lives = 3;
        Game.score = 0;
        Game.coins = 0;
        Game.items = [];
        Game.animationIntervals = [];
        Game.coinAnimationDirection = 1;
        Game.level;
        Game.log = (what) => {console.log(what)}
        Game.write = (what) => {document.write(what)}
        Game.clearCanvas = () => {canvas.clearRect(0, 0, canvasElem.getAttribute("width"), canvasElem.getAttribute("height"))}

    // Game physics stuff
        Game.fps = 60;
        Game.block = 16;
        Game.pixel = Game.block / 16;
        Game.subpixel = Game.pixel / 16;
        Game.subsubpixel = Game.subpixel / 16;
        Game.subsubsubpixel = Game.subsubpixel / 16;
        Game.getTotalValue = (b, p, sp, ssp, sssp) => {
            const   hexValues = {0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, a: 10, A: 10, b: 11, B: 11, c: 12, C: 12, d: 13, D: 13, e: 14, E: 14, f: 15, F: 15},
                    value = (what) => {return hexValues[what]}
            return (value(b) * Game.block) + (value(p) * Game.pixel) + (value(sp) * Game.subpixel) + (value(ssp) * Game.subsubpixel) + (value(sssp) * Game.subsubsubpixel);
        }

        // Used to indicate which sides of a hitbox are valid for collisions (to hopefully stop the game from having a seizure when mario falls directly between 2 tiles)
        // The index goes left, right, top, bottom
        // the indexes indicate which side of the tile are valid colliders, not the side that the entity touches the tile with
        Game.collisionCombos = [
            [true, true, true, true],       // left right top bottom
            [true, true, true, false],      // left right top
            [true, true, false, true],      // left right bottom
            [true, true, false, false],     // left right
            [true, false, true, true],      // left top bottom
            [true, false, true, false],     // left top
            [true, false, false, true],     // left bottom
            [true, false, false, false],    // left 
            [false, true, true, true],      // right top bottom
            [false, true, true, false],     // right top
            [false, true, false, true],     // right bottom
            [false, true, false, false],    // right
            [false, false, true, true],     // top bottom
            [false, false, true, false],    // top
            [false, false, false, true],    // bottom
            [false, false, false, false]   // none
        ];
        Game.pointValues = {
            brick: 50,
            coin: 200,
            powerUp: 1000,
            lakitu: 800,
            hammerBro: 1000,
            stompChain: [100, 200, 400, 500, 800, 1000, 2000, 4000, 5000, 8000, "1up"],
            shellChain: [500, 800, 1000, 2000, 4000, 5000, 8000, "1up"],
            shellKick: {
                ground: 400,
                afterStomp: [500, 800]//grants 500 or 800
            },
            fireball: {
                base: 200,
                goomba: 100,
                hammerBro: 1000,
                bowser: 5000
            },
            flagpole: [100, 400, 800, 2000, 5000], //this depends on pole height mario reaches
            bonusSeconds: 50 //bonus points granted for every remaining second on the level timer
        }
        class Entity {
            /*
                5 different units of measurement: block, pixel, subpixel, subsubpixel, and subsubsubpixel.
                Each value is 1/16 of the previous value (block=16, pixel=1, s-pixel = 1/16, etc)
                Each value ranges from 0 to 15 (on documentation its 0-F where A-F is 10-15)
                May be helpful to note that more often than not, blocks won't be used.

                Subsub- and subsubsubpixels do NOT factor into Mario's X position and are only used for precise accelerations
                A movement speed of 000xx will NOT move mario (furthermore, the xx position from the previous fram stays the same if he somehow comes to a stop)
                The following applies to ALL physics, not just ground physics:
                    If at any time, Mario's current X acceleration causes his X-Velocity to reach/exceed its current maximum, his ss- and ssspixel values drop to 0
                    If his Y-Velocity is reached/exceeded, the ss-, ss-, and ssspixel values drop to 0

                use an extra hitbox for entities that is 2 pixel larger than the actual hitbox
                use this to detect if the entity is 1 pixel away from a tile and if so, they are technically touching it
            */
            constructor(x, y, hitboxX, hitboxY, hitboxW, hitboxH, tileset, palette, sprite) {
                this.x = x;
                this.y = y;
                this.hitboxOffsets = {x: hitboxX, y: hitboxY, w: hitboxW, h: hitboxH}
                this.hitbox = {x: this.x + this.hitboxOffsets.x, y: this.y + this.hitboxOffsets.y, w: hitboxW, h: hitboxH}
                this.collisions = {left: false, right: false, top: false, bottom: false}
                this.tileset = tileset;
                this.palette = palette;
                this.sprite = sprite;
                this.collisionSide = false;
                this.w = this.sprite.length;
                this.h = this.sprite[1].length;
                this.hasTileBelow = false;
            
            }
            draw = () => Game.drawAsset(this);
            checkIfTouching(collider) {
                if (!collider) return false;
                let entityHitbox = this.hitbox, colliderProperty = collider.hitbox ? collider.hitbox : collider;
                return !(
                    entityHitbox.x > colliderProperty.x + colliderProperty.w ||
                    entityHitbox.x + entityHitbox.w < colliderProperty.x ||
                    entityHitbox.y > colliderProperty.y + colliderProperty.h ||
                    entityHitbox.y + entityHitbox.h < colliderProperty.y
                )
            }
            checkCollisionSide(collider) {
                if (collider) {
                    let colliderProperty = collider.hitbox ? collider.hitbox : collider;
                    if (this.checkIfTouching(collider)) {
                        let entityHitbox = this.hitbox,
                        entityHitboxHalfW = entityHitbox.w / 2,
                        entityHitboxHalfH = entityHitbox.h / 2,
                        colliderHalfW = colliderProperty.w / 2,
                        colliderHalfH = colliderProperty.h / 2,
                        entityHitboxCenterX = entityHitbox.x + entityHitbox.w / 2,
                        entityHitboxCenterY = entityHitbox.y + entityHitbox.h / 2,
                        colliderCenterX = colliderProperty.x + colliderProperty.w / 2,
                        colliderCenterY = colliderProperty.y + colliderProperty.h / 2,
                        
                        // Calculate the distance between centers
                        diffX = entityHitboxCenterX - colliderCenterX,
                        diffY = entityHitboxCenterY - colliderCenterY,
                        
                        // Calculate the minimum distance to separate along X and Y
                        minXDist = entityHitboxHalfW + colliderHalfW,
                        minYDist = entityHitboxHalfH + colliderHalfH,
                        
                        // Calculate the depth of collision for both the X and Y axis
                        depthX = diffX > 0 ? minXDist - diffX : -minXDist - diffX,
                        depthY = diffY > 0 ? minYDist - diffY : -minYDist - diffY;
                        // Now that you have the depth, you can pick the smaller depth and move along that axis.

                        /*
                            This is where the collision problem lies.
                            the collision between the player and the tile isnt deep enough on the top of the tile to trigger a y-axis collision
                            instead, the game detects an x-axis collision and the player falls straight through the tiles
                            check if tiles are only floors by checking if they have any collision on the top and none on left and right
                            only allow the function to return a y-level collision

                            chatgpt example:
                                check collision between multiple tiles at once
                                do this by finding a range of tiles that mario may be colliding with
                                check collision between mario and a new tile hitbox by creating a square using the tile coorinates
                        */
                        if (depthX != 0 && depthY != 0) {
                            if (Math.abs(depthX) < Math.abs(depthY)) {

                                // Collision along X axis. React accordingly
                                //                                             left                                             right
                                //this.x = depthX > 0 ? colliderProperty.x + colliderProperty.w - this.hitboxOffsets.x : colliderProperty.x - entityHitbox.w - this.hitboxOffsets.x;
                                return depthX > 0 ? "left" : "right";
                            } else {
                                // Collision along Y axis
                                //                                              top                                             bottom
                                //this.y = depthY > 0 ? colliderProperty.y + colliderProperty.h - this.hitboxOffsets.y : colliderProperty.y - entityHitbox.h - this.hitboxOffsets.y;
                                return depthY > 0 ? "top" : "bottom";
                            }
                        } else return false;
                    } else return false;
                }
            }
            checkCollisionSideNew(collider) {
                if (collider) {
                    let colliderProperty = collider.hitbox ? collider.hitbox : collider;
                    if (this.checkIfTouching(collider)) {
                        // Checks which side Mario is closest to, which determines the side he is colliding with
                        let overlapLeft = (collider.x + collider.w) - this.hitbox.x,
                            overlapRight = (this.hitbox.x + this.hitbox.w) - collider.x,
                            overlapTop = (collider.y + collider.h) - this.hitbox.y,
                            overlapBottom = (this.hitbox.y + this.hitbox.h) - collider.y,
                            minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom)
                        if (minOverlap == overlapLeft) return "left";
                        else if (minOverlap == overlapRight) return "right";
                        else if (minOverlap == overlapTop) return "top";
                        else if (minOverlap == overlapBottom) return "bottom";
                        else return false;
                    }
                }
            }
            largeLevelHitboxCollision() {
                // Collision for large hitboxes to stop mario from clipping and losing momentum
                let level = Game.worlds[Game.currentWorld][Game.currentLevel],
                    levelHitboxes = level.largeHitboxes;
                for (let hitboxIndex = 0; hitboxIndex < levelHitboxes.length; hitboxIndex ++) {
                    let levelHitbox = levelHitboxes[hitboxIndex];
                    this.collisionSide = this.checkCollisionSide(levelHitbox);
                    let entityHitbox = this.hitbox;
                    switch (this.collisionSide) {
                        case "left": {
                            this.collisions.left = true;
                            this.x = levelHitbox.x + levelHitbox.w - this.hitboxOffsets.x;
                            this.velocityX = 0;
                            this.accelerationX = 0;
                            break;
                        }
                        case "right": {
                            this.collisions.right = true;
                            this.x = levelHitbox.x - this.w + this.hitboxOffsets.x;
                            this.velocityX = 0;
                            this.accelerationX = 0;
                            break;
                        }
                        case "top": {
                            //this.collisions.top = true;
                            this.y = levelHitbox.y + levelHitbox.h - this.hitboxOffsets.y;
                            this.velocityY = this instanceof Mario ? this.physics.jumpPhysics[this.speedType].fallingGravity : this.velocityY * - 0.5;
                            //this.velocityY = 0;
                            this.jumping = true;

                            // checks tile hit and spawns item (if applicable)
                            let collisionTileIndexX = Math.round(mario.x / 16),
                                collisionTileIndexY = Math.round(mario.y / 16) - 1,
                                tileHit = level.tiles [collisionTileIndexY][collisionTileIndexX];
                            /*
                                when come back, go to seciton where collision checked between mario and items
                                add argument where item cant be picked up without canBeCollected being true
                            */
                            break;
                        }
                        case "bottom": {
                            this.collisions.bottom = true;
                            this.y = levelHitbox.y - this.hitboxOffsets.y - this.hitboxOffsets.h;
                            this.velocityY = 0;
                            this.gravity = 0;
                            this.jumping = false;
                            break;
                        }
                        case false: {
                            //this.gravity = this.physics.jumpPhysics[this.speedType].fallingGravity;
                            break;
                        }
                    }
                    this.updateHitboxes();
                    let hitboxIsBelow = false;
                    // Check if hitbox is 1 pixel below mario and if no, mario is falling and add falling gravity
                    if (!this.collisions.bottom && !hitboxIsBelow) {
                        
                        // Check if hitbox X value is close enough to mario
                        if (Math.floor(this.hitbox.x) < levelHitbox.x + levelHitbox.w && Math.floor(this.hitbox.x + this.hitbox.w) > levelHitbox.x) {
                            
                            // Check if hitbox is 1 pixel below mario
                            if  (Math.floor(this.hitbox.y) < levelHitbox.y && Math.floor(this.hitbox.y + this.hitbox.h) >= levelHitbox.y) {
                                this.collisionSide = "bottom";
                                this.jumping = false;
                                this.velocityY = 0;
                                this.gravity = 0;
                                this.collisions.bottom = true;
                                hitboxIsBelow = true;
                                this.hasTileBelow = true;
                                break;
                            } else {
                                this.jumping = true;
                                this.hasTileBelow = false;
                                this.gravity = this.physics.jumpPhysics[this.speedType][this.holdingJumpButton ? "holdingJumpGravity" : "fallingGravity"];
                            }
                        }
                    }
                }
            }
        }
        
        class Mario extends Entity {
            constructor(x, y) {
                /*
                    hitbox x y w h at different stages:
                        small: 4, 4, 8, 11
                        crouching: 4, 9, 11, 11
                        big: 4, 8/9, 11, 20/21
                */
                super(x, y, 4, 4, 8, 12, sprites.mario, sprites.colours.mario.overworld.normal, sprites.mario.small.stand);
                this.keys = {
                    left: false,
                    right: false,
                    up: false,
                    down: false,
                    sprint: false,
                    crouch: false
                }
                this.collisions = {
                    left: false,
                    right: false,
                    top: false,
                    bottom: false
                }
                this.maxFallSpeed = Game.getTotalValue(0, 4, 0, 0, 0); // 4 pixels per second
                this.holdingJumpButton = false;
                this.movementFromCrouch = {
                    left: false,
                    right: false,
                    lastMovement: ""
                }
                this.jumping = true;
                this.crouching = false;
                this.sprinting = false;
                this.skidding = false;
                this.accelerationX = 0;
                this.velocityX = 0;
                this.velocityY = 0;
                this.gravity = 0;
                this.lastMovementX = "";
                this.lastMovementY = "";
                this.directionAtStartOfJump = false;
                this.speedAtStartOfJump = 0;
                this.speedType = "lower";
                this.size = 1;
                this.lives = 3;

            // Physics stuff
                this.physics = {
                // Ground physics
                    groundPhysics: {
                        walk: {
                            minVelocity: Game.getTotalValue(0, 0, 1, 3, 0),
                            maxSpeed: Game.getTotalValue(0, 1, 9, 0, 0),
                            acceleration: Game.getTotalValue(0, 0, 0, 9, 8),
                            maxSpeedUnderwater: Game.getTotalValue(0, 1, 1, 0, 0),
                            maxSpeedLevelEntry: Game.getTotalValue(0, 0, "D", 0, 0)
                        },
                        run: {
                            acceleration: Game.getTotalValue(0, 0, 0, "E", 4),
                            maxSpeed:  Game.getTotalValue(0, 2, 9, 0, 0)
                        },
                        // When sprint button released and current direction is held, Mario keeps current speed for 10 frames then instantly slow to walk speed which is why speed isn't lost when throwing fireballs while running
                        releaseDeceleration: Game.getTotalValue(0, 0, 0, "D", 0),
                        // If player stops holding opposite direction and presses no other button, will continue to decelrate
                        skidDeceleration: Game.getTotalValue(0, 0, 1, "A", 0),
                        // The speed below/ at which Mario/Luigi changes direciton while skidding (ie he doesn't come to a complete stop first)
                        // This is the value that mario can be at or below in order to turn around and move in the opposite direction without stopping or skidding
                        // So if mario was at or below this speed and the player presses the opposite button, mario will immediately turn around and walk in the opposite direction without his speed going down so his speed will be immediately reversed
                        skidTurnaroundSpeed: Game.getTotalValue(0, 0, 9, 0, 0)
                    },
                // Air physics
                    /*
                        IMPORTANT!!
                        These are things that ALWAYS hold true:
                            Releasing the direction you go in will keep speed static, it will NOT slow you down
                            Holding/releasing jump/sprint button has NO EFFECT on midair momentum (meaning regardless of if you press or release the jump button, the speed will not be affected)
                            Midair physics underwater works EXACTLY how they do in air, same accelerations and everything else
                    */
                    // Values of midair momentum changes
                    airPhysics: {
                        // Holding forward in midair (to gain momentum)
                        gainMomentum: {
                            // If current speed is less than Game.getTotalValue(0, 1, 9, 0, 0)
                        lower: Game.getTotalValue(0, 0, 0, 9, 8),
                            // If current speed is more than/ equal to Game.getTotalValue(0, 0, 0, "E", 4")
                        higher: Game.getTotalValue(0, 0, 0, "E", 4)
                        },
                        // Holding back in midair (to lose momentum)
                        loseMomentum: {
                                // If speed is more than/ equal to Game.getTotalValue(0, 1, 9, 0, 0)
                            higher: Game.getTotalValue(0, 0, 0, "E", 4),
                                // If speed is lower than Game.getTotalValue(0, 1, 9, 0, 0) and speed at start of jump is more than/ equal to Game.getTotalValue(0, 1, "D", 0, 0)
                            lower: {
                                highJumpStart: Game.getTotalValue(0, 0, 0, "D", 0),
                                // If speed is lower than Game.getTotalValue(0, 1, 9, 0, 0) and speed at start of jump is less than Game.getTotalValue(0, 1, "D", 0, 0)
                                lowJumpStart: Game.getTotalValue(0, 0, 0, 9, 8)
                            }
                        }
                    },
                // Jumping/ vertical physics
                    /*
                        As long as jump button is held, Mario will rise at a slowing rate.
                        As soon as jump button is released, Mario immediately starts falling
                        Vertical downward velocity caps at Game.getTotalValue(0, 4, 8, 0, 0), and wraps back to Game.getTotalValue(0, 4, 0, 0, 0) when max velocity is exceeded

                        Running of a ledge doesn't use any specific gravity but instead uses whatever the previous falling gravity was
                    */
                    jumpPhysics: {
                        // Initial horizontal speed less than Game.getTotalValue(0, 1, 0, 0, 0)
                        lower: {
                            // Initial velocity (-y)
                            initalVelocity: Game.getTotalValue(0, 4, 0, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 2, 0, 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 7, 0, 0),
                        },
                        // Initial horizontal speed between Game.getTotalValue(0, 1, 0, 0, 0) and Game.getTotalValue(0, 2, 4, "F", "F")
                        between: {
                            // Initial velocity (-y)
                            initalVelocity: Game.getTotalValue(0, 4, 0, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 1, "E", 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 7, 0, 0),
                        },
                        // Initial horizontal speed more than/equal to Game.getTotalValue(0, 2, 5, 0, 0)
                        greater: {
                            // Initial velocity (-y)
                            initalVelocity: Game.getTotalValue(0, 5, 0, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 2, 8, 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 9, 0, 0),
                        },
                        // Initial horizontal speed is level entry speed
                        entry: {
                            // Initial velocity (-y)
                            initalVelocity: Game.getTotalValue(0, 0, 0, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 2, 8, 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 2, 8, 0)
                        },
                    },
                // Swimming Physics
                    /*
                        Underwater and ground levels have similar physics.
                        Swimming is treated almost identical to jumping, but with lower gravity.
                        Just like jumping, gravity values only reset on pressing jump button, meaning that if you swim out of a whirlpool, you will keep the lower gravity values.
                        Whirlpools extend exactly 1 block from the edges of a pit. Unlike other gravity changes, the "surface" gravity while in or above darkened segment (shown on documentation image).
                        While in whirlpools, mario Y-speed caps at Game.getTotalValue(0, 1, 8, 0, 0) rather than Game.getTotalValue(0, 4, 8, 0, 0), and an additional Game.getTotalValue(0, 0, 1, 0, 0) is added to his current gravity.
                        If Mario has a current positive Y-Velocity of V (i think this means the initial velocity variable), then his Y-position doesn't change by V every frame (as it would in any other case), but by the value of (2V + gravity).
                        While in the whirlpool region, Mario is moved 1 pixel towards the center of the pit every other frame
                    */
                    swimPhysics: {
                        // Initial horizontal speed is normal
                        normal: {
                            // Initial velocity (-y)
                            initial: Game.getTotalValue(0, 1, 8, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 0, "D", 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 0, "A", 0)
                        },
                        // Initial horizontal speed is in whirlpool zone
                        whirlpool: {
                            // Initial velocity (-y)
                            initial: Game.getTotalValue(0, 1, 0, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 0, 4, 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 0, 9, 0)
                        },
                        // Initial horizontal speed is in surface zone
                        surface: {
                            // Initial velocity (-y)
                            initial: Game.getTotalValue(0, 1, 8, 0, 0),
                            // Holding jump button gravity (+y)
                            holdingJumpGravity: Game.getTotalValue(0, 0, 1, 8, 0),
                            // Falling gravity (+y)
                            fallingGravity: Game.getTotalValue(0, 0, 1, 8, 0)
                        }
                    },
                // Other Physics
                    /*
                        Other physics that don't fit into other categories.
                        xxx means that the s-, ss-, and ssspixel values are kept from the previous frame
                    */
                    otherPhysics: {
                        // Climbing stuff
                        climb: {
                            velocity: {
                                // Ascending (-y)
                                ascend: Game.getTotalValue(0, 0, "E", 0, 0),
                                // Descending (+y)
                                descend: Game.getTotalValue(2, 0, 0, 0, 0)
                            },
                            gravity: Game.getTotalValue(0, 0, 0, 0, 0)
                        },
                        // When stomping on enemies like squashing a Goomba
                        stomp: {
                            goombaAndShell: {
                                velocity: Game.getTotalValue(),
                                gravity: Game.getTotalValue()
                            },
                            lakituBroCheepBullet: {
                                velocity: Game.getTotalValue(0, 3, "x", "x", "x"),
                                gravity: "last" // The fact that stomps don't have a fixed gravity means that if you stomp and enemy while moving upwards and are still holding jump button, you can continue to hold it to reduce gravity which results in a huge height boost
                            },
                            trampoline: {
                                normal: {
                                    velocity: Game.getTotalValue(0, 7, 0, 0, 0),
                                    gravity: "last" // This means that a trampoline jump at walk speed will propel you much higher than a running jump
                                },
                                holdingJumpGravity: {
                                    velocity: Game.getTotalValue(0, "c", 0, 0, 0),
                                    gravity: "last"
                                },
                                superTrampoline: {// Only with holding jump button
                                    velocity: Game.getTotalValue(2, 0, 0, 0, 0),
                                    gravity: Game.getTotalValue(0, 0, 7, 0, 0)
                                }
                            }
                        },
                        /*
                            The game changes the picel unit two frames before hitting a block/ceiling, and calculates the difference between the replaced and replacement values, and subtracts this number from Marios Y-Position 2 frames later.
                            For example. you are 3 frames away from a hit block with a velocity of -02000 and a gravity of 00700.
                            Your speed next fram will be 01700 but you will move a distance of -01900. Then the speed next frame would be 01E00 and you will move a distance of -01200.
                            next frame, your speed and change distance will both be 02500.
                        */
                        ceilingHit: {
                            // Hitting untouched ? blocks or hitting bricks while small
                            soft: {
                                velocity: Game.getTotalValue(0, 0, "x", "x", "x"),
                                gravity: "last"
                            },
                            // Hitting anything else (static/unbreakable blocks)
                            hard: {
                                velocity: Game.getTotalValue(0, 1, "x", "x", "x"),
                                gravity: "last"
                            }
                        }
                    }
                }
                /*
                    mario clips to the top of the 

                    entities are always 1 pixel into the block so make hitboxes of entities 1 pixel higher
                */
            }

            // Changes player values based on keypresses and player speed
            // Handles ground movements
            groundMovement() {
                // Determines which values to use based on if mario is walking or running
                let playerMovementTypeX = this.sprinting ? "run" : "walk";
                if (!this.jumping && this.hasTileBelow)
            // walking acceleration logic
                // Logic when player walks left
                if (this.keys.left) {

                    // When player reaches max walk speed
                    if (this.velocityX <= -this.physics.groundPhysics[playerMovementTypeX].maxSpeed) {
                        this.velocityX = -this.physics.groundPhysics[playerMovementTypeX].maxSpeed;
                        this.accelerationX = 0;
                    }

                    // When player begins walking left
                    else if (this.velocityX == 0) this.accelerationX = -this.physics.groundPhysics.walk.minVelocity;

                    // Logic for quick turn-around
                    else if (this.velocityX < this.physics.groundPhysics.skidTurnaroundSpeed && this.velocityX > 0) this.velocityX = -this.physics.groundPhysics.walk.minVelocity;

                    // Logic when nothing special happening so player accelerates regularly
                    else this.accelerationX = -this.physics.groundPhysics[playerMovementTypeX].acceleration;

                // Logic when player moves right
                } else if (this.keys.right) {

                    // When player reaches max move speed
                    if (this.velocityX >= this.physics.groundPhysics[playerMovementTypeX].maxSpeed) {
                        this.velocityX = this.physics.groundPhysics[playerMovementTypeX].maxSpeed;
                        this.accelerationX = 0;
                    }
                        
                    // When player begins moving right
                    else if (this.velocityX == 0) this.accelerationX = this.physics.groundPhysics.walk.minVelocity;

                    // Logic for quick turn-around
                    else if (this.velocityX > -this.physics.groundPhysics.skidTurnaroundSpeed && this.velocityX < 0) this.velocityX = this.physics.groundPhysics.walk.minVelocity;

                    // Logic when nothing special happening so player accelerates regularly
                    else this.accelerationX = this.physics.groundPhysics[playerMovementTypeX].acceleration;

            // Walking deceleration Logic
                } else if (this.lastMovementX) {

                    // Logic when last button pressed is left
                    if (this.lastMovementX == "left") {

                        // When player releases movement button and coasts to a stop
                        if (this.velocityX < 0) this.accelerationX = this.physics.groundPhysics.releaseDeceleration;
                        
                        // When player presses opposite movement button to skid
                        else if (this.velocityX > 0) this.skidding = true;
                        
                        // When player releases opposite movement button and decelerates to stop from skidding
                        else {
                            this.lastMovementX = "";
                            this.velocityX = 0;
                            this.accelerationX = 0;
                        }
                    }

                    // Logic when last button pressed is right
                    else if (this.lastMovementX == "right") {

                        // When player releases movement button and coasts to a stop
                        if (this.velocityX > 0) this.accelerationX = -this.physics.groundPhysics.releaseDeceleration;

                        // When player presses opposite movement button to skid
                        else if (this.velocityX < 0) this.skidding = true;
                        
                        // when player releases opposite movement button and decelerates to stop from skkidding
                        else {
                            this.lastMovementX = "";
                            this.velocityX = 0;
                            this.accelerationX = 0;
                        }
                    }
                } else {
                    this.accelerationX = 0;
                    this.velocityX = 0;
                }
            
            // Skidding physics
                if (this.skidding) {

                    // Left skid
                    if (this.lastMovementX == "left") {

                        // Player is skidding. Pressing/releasing movement button has no effect and will decelerate at same rate to 0
                        if (this.velocityX > 0) this.accelerationX = -this.physics.groundPhysics.skidDeceleration;

                        // Player velocity has reached opposite velocity so velocity and acceleration go to 0 to stop movement in opposite direction
                        else {
                            this.velocityX = 0;
                            this.accelerationX = 0;
                            this.skidding = false;
                        }

                    // Right skid
                    } else if (this.lastMovementX == "right") {

                        // Player is skidding. Pressing/releasing movement button has no effect and will decelerate at same rate to 0
                        if (this.velocityX < 0) this.accelerationX = this.physics.groundPhysics.skidDeceleration;

                        // Player velocity has reached opposite velocity so velocity and acceleration go to 0 to stop movement in opposite direction
                        else {
                            this.velocityX = 0;
                            this.accelerationX = 0;
                            this.skidding = false;
                        }
                    }
                }
            }
            
            // Handles air movement
            airMovement() {
                let velocityParamY = (this.holdingJumpButton ? "holdingJump" : "falling") + "Gravity";
                if (this.keys.up) {
                    if (!this.jumping && !this.holdingJumpButton) {
                        this.directionAtStartOfJump = this.lastMovementX;
                        this.speedAtStartOfJump = this.velocityX;
                        this.holdingJumpButton = true;
                        this.jumping = true;

                        // This determines what kind of variables mario uses depending on how fast he is moving

                        // // If X velocity is positive
                        if (this.speedAtStartOfJump > 0) {

                            // Lower
                            if (this.speedAtStartOfJump < Game.getTotalValue(0, 1, 0, 0, 0)) this.speedType = "lower";

                            // Between
                            else if (this.speedAtStartOfJump >= Game.getTotalValue(0, 1, 0, 0, 0) && this.speedAtStartOfJump <= Game.getTotalValue(0, 2, 4, "F", "F")) this.speedType = "between";

                            // Higher
                            else if (this.speedAtStartOfJump >= Game.getTotalValue(0, 2, 5, 0, 0)) this.speedType = "greater";

                        // If X velocity is negative
                        } else if (this.speedAtStartOfJump < 0) {

                            // Lower
                            if (this.speedAtStartOfJump > -Game.getTotalValue(0, 1, 0, 0, 0)) 
                                //this.velocityY = this.physics.jumpPhysics.lower.initalVelocity;
                                this.speedType = "lower";
                            
                            // Between
                            else if (this.speedAtStartOfJump <= -Game.getTotalValue(0, 1, 0, 0, 0) && this.speedAtStartOfJump >= -Game.getTotalValue(0, 2, 4, "F", "F")) 
                                //this.velocityY = this.physics.jumpPhysics.between.initalVelocity;
                                this.speedType = "between";

                                // Higher
                            else if (this.speedAtStartOfJump >= -Game.getTotalValue(0, 2, 5, 0, 0)) 
                                //this.velocityY = this.physics.jumpPhysics.greater.initalVelocity;
                                this.speedType = "greater";
                            

                        // Level entry velocity stuff
                        } else {

                        }
                        this.velocityY = -this.physics.jumpPhysics[this.speedType].initalVelocity;
                        this.sprinting = this.keys.sprint;
                    } else this.gravity = this.physics.jumpPhysics[this.speedType][velocityParamY];
                }
                /*
                NOTE:   releasing direction of movement while midair will keep speed the same and will not slow down
                holding/releasing jump has NO effect on midair momentum, so will stay the same / continue changin regardless of the jump button
                */
                if (mario.jumping) {
                    /*
                        mario moving left/right at start of jump:
                            if current direction key = start jump direction:
                                use air acceleration
                            if current direction key = opposite direction:
                                use air deceleration
                            if no current direction key:
                                maintain velocity (do not accelerate/decelerate)
                    */
                // Both/no key pressed. Momentum remains constant
                    if (!this.keys.left && !this.keys.right) this.accelerationX = 0;
                        
                // Moving left at start of jump
                    else {
                        if (this.directionAtStartOfJump == "left") {

                            // If direction button is the same as direction at the start of the jump (or if no direction is currently held)
                            if (this.lastMovementX == this.directionAtStartOfJump) this.accelerationX = -this.physics.airPhysics.gainMomentum[this.velocityX < -Game.getTotalValue(0, 1, 9, 0, 0) ? "higher" : "lower"];
                            
                            // If direction button is opposite to direction at the start of the jump
                            else {
                                
                                // If X velocity when moving left is greater than getTotalValue(0, 1, 9, 0, 0)
                                if (this.velocityX <= -Game.getTotalValue(0, 1, 9, 0, 0)) this.accelerationX = this.physics.airPhysics.loseMomentum.higher;

                                // If X velocity when moving left is less than getTotalValue(0, 1, 9, 0, 0) and speed at start of jump is less than getTotalValue(0, 1, "D", 0, 0)
                                else if (this.velocityX >= -Game.getTotalValue(0, 1, 9, 0, 0) && this.speedAtStartOfJump <= -Game.getTotalValue(0, 1, "D", 0, 0)) this.accelerationX = this.physics.airPhysics.loseMomentum.lower.highJumpStart;

                                // If X velocity when moving left is less than getTotalValue(0, 1, 9, 0, 0) and speed at start of jump is greater than getTotalValue(0, 1, "D", 0, 0)
                                else if (this.velocityX >= -Game.getTotalValue(0, 1, 9, 0, 0) && this.speedAtStartOfJump > -Game.getTotalValue(0, 1, "D", 0, 0)) this.accelerationX = this.physics.airPhysics.loseMomentum.lower.lowJumpStart;
                            }

                    // Moving right at start of jump
                        } else if (this.directionAtStartOfJump == "right") {

                            // If direction button is the same as direction at the start of the jump (or if no direction is currently held)
                            if (this.lastMovementX == this.directionAtStartOfJump) this.accelerationX = this.physics.airPhysics.gainMomentum[this.velocityX >= Game.getTotalValue(0, 1, 9, 0, 0) ? "higher" : "lower"];
                            
                            // If direction button is opposite to direction at the start of the jump
                            else {

                                // If X velocity when moving right is greater than getTotalValue(0, 1, 9, 0, 0)
                                if (this.velocityX >= Game.getTotalValue(0, 1, 9, 0, 0)) this.accelerationX = -this.physics.airPhysics.loseMomentum.higher;

                                // If X velocity when moving right is less than getTotalvalue(0, 1, 9, 0, 0) and speed at start of jump is less than getTotalValue(0, 1, "D", 0, 0)
                                else if (this.velocityX <= Game.getTotalValue(0, 1, 9, 0, 0) && this.speedAtStartOfJump >= Game.getTotalValue(0, 1, "D", 0, 0)) this.accelerationX = -this.physics.airPhysics.loseMomentum.lower.highJumpStart;

                                // If X velociry when moving left is less than getTotalValue(0, 1, 9, 0, 0) and speed at start of jump is less than getTotalValue(0, 1, "D", 0, 0)
                                else if (this.velocityX <= Game.getTotalValue(0, 1, 9, 0, 0) && this.speedAtStartOfJump < Game.getTotalValue(0, 1, "D", 0, 0)) this.accelerationX = -this.physics.airPhysics.loseMomentum.lower.lowJumpStart;
                            }

                    // If mario starts jump standing still
                        } else {
                            if (this.keys.left && !this.keys.right) {
                                this.accelerationX = -this.physics.airPhysics.gainMomentum[this.velocityX < -Game.getTotalValue(0, 1, 9, 0, 0) ? "higher" : "lower"];
                                this.lastMovementX = "left";
                            } else if (this.keys.right && !this.keys.left) {
                                this.accelerationX = this.physics.airPhysics.gainMomentum[this.velocityX > Game.getTotalValue(0, 1, 9, 0, 0) ? "higher" : "lower"];
                                this.lastMovementX = "right";
                            }
                        }
                    }
                }
            }

            // Handles water movement
            //will cross this shitty bridge when i come to it
            waterMovement() {

            }

            // Changes Mario's size when he is hit
            changeSize() {
                switch (this.size) {

                    // Small to big
                    case 1: // Small
                        // Mario's sprite needs to be changed to standing for the grow animation
                        this.sprite = sprites.mario.small.stand;
                        /*
                            this is where the small-to-big animation will play.
                            when mario picks up mushroom, animation plays, making him bigger
                            when animation finished, y-coord needds to be increased by 16 (i think, may be subject to change)
                        */

                        // Grow animation
                        //animation here

                        // Final sprite for animation
                        this.sprite = sprites.mario.big.stand;

                        // Y-axis modification
                        this.y -= 16;
                        this.hitbox.y -= 16;

                        // Readjusting hitboxes
                        this.hitboxOffsets = {x: 2, y: 8, w: 12, h: 24}
                        this.hitbox = {x: this.x + this.hitboxOffsets.x, y: this.y + this.hitboxOffsets.y, w: this.hitboxOffsets.w, h: this.hitboxOffsets.h}
                        this.size = 2;
                        return true;

                    // Big to small
                    case 2: // Big
                        // Mario's sprite needs to be changed to standing for the shrink animation
                        this.sprite = sprites.mario.big.stand;
                        /*
                            this is where the big-to-small animation will play.
                            when mario is hit, animation plays, making him smaller
                            when animation finished, y-coord needds to be decreased by 16 (i think, may be subject to change)
                        */

                        // Shrink animation
                        //animation here

                        // Final sprite for animation
                        this.sprite = sprites.mario.small.stand;

                        // Y-axis modification
                        this.y += 16;
                        this.h = 13;

                        this.hitboxOffsets = {x: 4, y: 4, w: 8, h: 12}
                        this.hitbox = {x: this.x + this.hitboxOffsets.x, y: this.y + this.hitboxOffsets.y, w: this.hitboxOffsets.w, h: this.hitboxOffsets.h}
                        this.size = 1;
                        return true;
                }
            }

            // Resets collision side values
            resetCollision() {
                this.collisions.left = false;
                this.collisions.right = false;
                this.collisions.top = false;
                this.collisions.bottom = false;
            }

            // Updates coordinates
            updateCoords() {
                this.velocityX += this.accelerationX;
                this.velocityY += this.gravity;
                this.x += this.velocityX;
                this.y += this.velocityY;
            }

            // Updates hitboxes
            updateHitboxes() {
                this.hitbox.x = this.x + this.hitboxOffsets.x;
                this.hitbox.y = this.y + this.hitboxOffsets.y;
            }

            // Updates player values
            update() {
                this.resetCollision();
                this.updateCoords();
                this.updateHitboxes();

                //mario max fall speed if 04800 and wraps back to 04000 when exceeded
                if (this.velocityY >= Game.getTotalValue(0, 4, 8, 0, 0)) this.velocityY = Game.getTotalValue(0, 4, 0, 0, 0);

            // Checks for reaching/exceeding maximum walk/run velocity
                // Run velocity
                if (this.sprinting) {

                    // If mario moving right
                    if (this.velocityX >= this.physics.groundPhysics.run.maxSpeed) {
                        this.accelerationX = 0;
                        this.velocityX = this.physics.groundPhysics.run.maxSpeed;
                        
                    // If mario moving left
                    } else if (this.velocityX <= -this.physics.groundPhysics.run.maxSpeed) {
                        this.accelerationX = 0;
                        this.velocityX = -this.physics.groundPhysics.run.maxSpeed;
                    }
                // Walk velocity
                } else {

                    // If mario moving right
                    if (this.velocityX >= this.physics.groundPhysics.walk.maxSpeed) {
                        this.accelerationX = 0;
                        this.velocityX = this.physics.groundPhysics.walk.maxSpeed;

                    // If mario moving left
                    } else if (this.velocityX <= -this.physics.groundPhysics.walk.maxSpeed) {
                        this.accelerationX = 0;
                        this.velocityX = -this.physics.groundPhysics.walk.maxSpeed;
                    }
                }
            }

            // Draws hitboxes. Used for debugging
            drawHitbox(colour) {
                canvas.beginPath();
                canvas.fillStyle = colour;
                canvas.fillRect(mario.hitbox.x, mario.hitbox.y, mario.hitbox.w, mario.hitbox.h);
            }
            
            // Enables crouching
            crouch() {
                if (this.size != 2 || this.jumping) return false;
                if (!this.crouching) this.y += 8;
                //mario cannot crouch in midair
                this.accelerationX = 0;

                // applies last movement value from left and right to allow movement directly after crouching
                if (this.lastMovementX) this.movementFromCrouch.lastmovement = this.lastMovementX;
                this.keys.left = false;
                this.keys.right = false;
                this.sprite = sprites.mario.big.crouch;
                this.hitboxOffsets = {x: 3, y: 12, w: 10, h: 12}
                this.hitbox = {x: this.x + this.hitboxOffsets.x, y: this.y + this.hitboxOffsets.y, w: this.hitboxOffsets.w, h: this.hitboxOffsets.h}
                this.crouching = true;
            }

            // Stand up from crouch 
            standUp() {
                if (this.size != 2) return false;
                
                // Reapplies original movement values to make player move again after crouching
                this.keys.left = this.movementFromCrouch.left;
                this.keys.right = this.movementFromCrouch.right;
                this.lastMovementX = this.movementFromCrouch.lastMovement;
                if (!(this.keys.left && this.keys.right)) this.lastMovementX = this.keys.left ? "left" : "right";
                
                // Returns placeholder values to false for next crouch (probably unneccesary, will keep commented until needed)
                //this.movementFromCrouch = {left: false, right: false}

                this.crouching = false;
                this.sprite = sprites.mario.big.stand;
                this.hitboxOffsets = {x: 2, y: 8, w: 12, h: 24}
                this.hitbox = {x: this.x + this.hitboxOffsets.x, y: this.y + this.hitboxOffsets.y, w: this.hitboxOffsets.w, h: this.hitboxOffsets.h}
            }

            // Moves mario and checks collision
            move() {

                // Ground movement
                this.groundMovement();

                // Air movement
                this.airMovement();
                
                // Updates player position and velocity
                this.update();
                
                /*
                    THIS FUNCTION NEEDS REWORKING
                    the function runs through tiles so many times, when it only needs to run through them once or twice
                    what each loop does:
                        first loop (with comment "Tile collision"):
                            checks collision of individual tiles throughout the level
                            sets this.collisions to true depending on collision side
                            if collision is the top of player (bottom of tile), checks if tile is breakable and then sets isBroken to true
                            then runs through large hitboxes checking which hitbox the tile is within
                            when found, the tile is removed from the list of tiles and then the large hitboxes are recreated.
                                nested loop:
                                    checks through each row to check if tile is contained within row, and if so sets isBroken to true.
                            if tile isn't breakable, checks if tile has contents and if so then spawn

                            if tile not broken, checks collision side of tile, and changes physics values based on the side hit, and updates hitboxes
                */

                // Mushroom bounce method. Here instead of in tile collision as no collision will be detected due to large hitboxes
                Game.items.forEach(item => {
                    if (item instanceof Mushroom)
                    Game.worlds[Game.currentWorld][Game.currentLevel].tiles.forEach(row => row.forEach(tile => {
                        if (this.checkIfTouching(tile)) {
                            item.bounce(tile);
                        }
                    }))
                })

                //this.largeLevelHitboxCollision()
                // Mario crouch stuff
                if (this.size == 2 && this.keys.down) this.crouch();

                let level = Game.worlds[Game.currentWorld][Game.currentLevel],
                    levelTiles = level.tiles,
                    playerIndex = Math.floor(this.x / 16),
                    endColumnIndex = playerIndex + 1;
                playerIndex -= (playerIndex > 0 ? 1 : 0);
                let numberOfColumnsToCheck = endColumnIndex - playerIndex;
                //try using Math.floor() when drawing tiles, as this may help with visual clarity and do the same with mario
                /*
                    try using some sort of pythagoras shit to determine if any tiles will coincide with the new position after moving
                    will need original coords (x1 and y1) and coords after applying velocity (x2 and y2)
                    will be something like: (x2 - x1) * (x2 - x1) and (y2 - y1) * (y2 - y1)

                    just have a look at the map/grid/coordinate formulas to find the correct formula for translation

                    new idea: add all variants of tiles wherein the necessary collision sides are given in the tileList, not when creating a new tile
               */
                this.largeLevelHitboxCollision();
                for (let row = 0; row < levelTiles.length; row ++) {
                    for (let column = playerIndex; column <= endColumnIndex; column ++) {
                        let tile = levelTiles[row][column];
                        if (tile instanceof Tile && !tile.isBroken) {
                            let hitbox = this.hitbox,
                                collisionSide = this.checkCollisionSideNew(tile);
                            // Checks if hitboxes are colliding
                            switch (collisionSide) {
                                case "false":
                                    if (this.collisions.bottom) {
                                        this.gravity = 0;
                                        this.velocityY = 0
                                    } else this.jumping = true;
                                    continue;
                                case "left":
                                    if (tile.validCollisionSides[1] && !this.collisions.left) {
                                        this.collisions.left = true;
                                        this.x = tile.x + tile.w - this.hitboxOffsets.x;
                                        this.velocityX = 0;
                                        this.accelerationX = 0;
                                    }
                                    continue;
                                case "right":
                                    if (tile.validCollisionSides[0] && !this.collisions.right) {
                                        this.collisions.right = true;
                                        this.x = tile.x - this.w + this.hitboxOffsets.x;
                                        this.velocityX = 0;
                                        this.accelerationX = 0;
                                    }
                                    continue
                                case "top":
                                    if (tile.validCollisionSides[3] && !this.collisions.top) {
                                        this.collisions.top = true;
                                        this.y = tile.y + tile.h - this.hitboxOffsets.y;
                                        this.velocityY = 0;
                                        if (tile.breakable) {
                                            tile.isBroken = true;
                                            // Loop to check which large hitbox the tile is contained in
                                            level.largeHitboxes.forEach(box => {
                                                if (!
                                                    (box.x > tile.x + tile.w ||
                                                    box.x + box.w < tile.x ||
                                                    box.y > tile.y + tile.h ||
                                                    box.y + box.h < tile.y
                                                    )) {
                                                        let tileX = Math.floor(tile.x / 16),
                                                            tileY = Math.floor(tile.y / 16)
                                                        level.tiles[tileY][tileX] = null;
                                                        //("y")
                                                        level.createLargeHitboxes();
                                                    }
                                            })
                                        } else {
                                            let item = Game.items[Game.items.indexOf(tile.contents)]
                                            if (tile.contents && !tile.contents.spawned) item.spawn();
                                        }
                                    }
                                    continue;
                                case "bottom":
                                    if (tile.validCollisionSides[2]) {
                                        this.collisions.bottom = true;
                                        this.y = tile.y - this.hitboxOffsets.y - this.hitbox.h;
                                        this.speedAtStartOfJump = 0;
                                        this.velocityY = 0;
                                        this.gravity = 0;
                                        this.jumping = false;
                                    }
                                    continue;
                            }
                            this.updateHitboxes();
                        }
                    }
                }
                /*if (!this.collisions.bottom) this.gravity = this.physics.jumpPhysics[this.speedType].fallingGravity;
                // Tile collision
                for (let collisionRow = 0; collisionRow < levelTiles.length; collisionRow ++) {
                    for (let collisionColumn = playerIndex; collisionColumn <= endColumnIndex; collisionColumn ++) {
                        let tile = levelTiles[collisionRow][collisionColumn];
                        if (tile instanceof Tile) {
                            if (!tile.isBroken) {
                                // New collision shit
                                let entityHitbox = this.hitbox;
                                // Checks if hitboxes are colliding
                                if (entityHitbox.x + entityHitbox.w >= tile.x &&    // Entity right edge past tile left
                                    entityHitbox.x <= tile.x + tile.w &&            // Entity left edge past tile right
                                    entityHitbox.y + entityHitbox.h >= tile.y &&    // Entity top edge past tile bottom
                                    entityHitbox.y <= tile.y + tile.h) {            // Entity bottom edge past tile top
                                    // Checks which specific side the hitboxes are colliding on
                                    //will need some way to check which side of player hitbox is deeper if there are multiple sides colliding at once
                                    // Left side
                                    let overlapLeft = (entityHitbox.x + entityHitbox.w) - tile.x,
                                        overlapRight = (tile.x + tile.w) - entityHitbox.x,
                                        overlapTop = (entityHitbox.y + entityHitbox.h) - tile.y,
                                        overlapBottom = (tile.y + tile.h) - entityHitbox.y,
                                        minOverlap = Math.min(overlapLeft, overlapRight, overlapTop, overlapBottom);
                                    switch (minOverlap) {
                                        case overlapLeft: { // Left side of tile, right side of player
                                            if (tile.validCollisionSides[0] && !this.collisions.right) {
                                                this.collisions.right = true;
                                                this.x = tile.x - this.w + this.hitboxOffsets.x;
                                                this.velocityX = 0;
                                                this.accelerationX = 0;
                                            }
                                            continue;
                                        }
                                        case overlapRight: { // Right side of tile, left side of player
                                            if (tile.validCollisionSides[1] && !this.collisions.left) {
                                                this.collisions.left = true;
                                                this.x = tile.x + tile.w - this.hitboxOffsets.x;
                                                this.velocityX = 0;
                                                this.accelerationX = 0;
                                            }
                                            continue;
                                        }
                                        case overlapTop: { // Top of tile, bottom of player
                                            if (tile.validCollisionSides[2]) {
                                                this.collisions.bottom = true;
                                                this.y = tile.y - this.hitboxOffsets.y - this.hitbox.h;
                                                this.speedAtStartOfJump = 0;
                                                this.velocityY = 0;
                                                this.gravity = 0;
                                                this.jumping = false;
                                            }
                                            continue;
                                        }
                                        case overlapBottom: { // Bottom of tile, top of player
                                            if (tile.validCollisionSides[3]) {
                                                this.collisions.top = true;
                                                this.y = tile.y + tile.h - this.hitboxOffsets.y;
                                                this.velocityY = 0;
                                                if (tile.breakable) {
                                                    tile.isBroken = true;
                                                    // Loop to check collision between large hitbox and tle to see which hitbox the tile is in
                                                    level.largeHitboxes.forEach(hitbox => {
                                                        // Checks if tile is in large hitbox
                                                        if (!
                                                            (hitbox.x > tile.x + tile.w ||
                                                            hitbox.x + hitbox.w < tile.x ||
                                                            hitbox.y > tile.y + tile.h ||
                                                            hitbox.y + hitbox.h < tile.y)
                                                        ) {
                                                            let tileX = tile.x / 16,
                                                                tileY = tile.y / 16;
                                                            let indexedTile = level.tiles[tileY][tileX];
                                                            level.tiles[tileY][tileX] = null;
                                                            level.createLargeHitboxes();
                                                            
                                                        }
                                                    })
                                                } else {
                                                    let item = Game.items[Game.items.indexOf(tile.contents)]
                                                    if (tile.contents && !tile.contents.spawned) item.spawn();
                                                }
                                                continue;
                                            }
                                        }
                                    }
                                } else {
                                    if (this.collisions.bottom) {
                                        this.gravity = 0;
                                        this.velocityY = 0;
                                    } else this.jumping = true;
                                }
                            }
                        }
                    }
                }*/
                if (!this.collisions.bottom) this.gravity = this.physics.jumpPhysics[this.speedType].fallingGravity;
            }
            // Changes mario based on his size
            onhit() {
                // If mario invincible (star ability) do nothing
                // Else if Mario is big make small
                // else kill, lose life, restart from checkpoint (Start of level or middle of level (I think))
            }
            
            // Checks how many lives mario has. will either take away a life and check if game over, or just check game over
            checkLives() {
                // If lives == 0, game over
                // Else restart from checkpoint (reset size)
            }
        }
        
        class Enemy extends Entity {
            constructor(x, y, hitboxX, hitboxY, hitboxW, hitboxH, tileset, palette, sprite, enemyClass) {
                super(
                    x,
                    y,
                    hitboxX,
                    hitboxY,
                    hitboxW,
                    hitboxH,
                    tileset,
                    palette
                );          
            }
        }
        
        class Item {
            constructor(x, y, hitboxX, hitboxY, hitboxW, hitboxH) { // Value is the number of points given when picked up
                this.x = x;
                this.y = y;
                this.hitboxOffsets = {x: hitboxX, y: hitboxY, w: hitboxW, h: hitboxH}
                this.hitbox = {x: this.x + hitboxX, y: this.y + hitboxY, w: hitboxW, h: hitboxH}
                this.value = Game.pointValues.powerUp;
                this.collected = false;
                this.canBeCollected = false;
                this.hasTileBelow = false;
            }

            checkIfTouching(collider) {
                return !(
                    collider.x > this.hitbox.x + this.hitbox.w ||
                    collider.x + collider.w < this.hitbox.x ||
                    collider.y > this.hitbox.y + this.hitbox.h ||
                    collider.y + collider.h < this.hitbox.y
                )
            }

            // Checks if there is a tile 1 pixel below item to stop it from falling
            checkIfBelow(collider) {
                if (collider)
                /*
                    if item y + item h < tile h 
                    and
                    item y + item h > tile h - 1
                */

                // Check if collider is close enough to the tile
                if (Math.floor(this.hitbox.x) < collider.x + collider.w && Math.floor(this.hitbox.x + this.hitbox.w) > collider.x) {

                    // Check if collider is 1 pixel below item
                    if (this.hitbox.y + this.hitbox.h == collider.y) {
                        return true;
                    }
                }
                return false;
            }

            checkTileCollision(obj) {
                if (this.collected) return false;
                if (obj && this.checkIfTouching(obj)) {
                    let entityHitboxHalfW = this.hitbox.w / 2,
                        entityHitboxHalfH = this.hitbox.h / 2,
                        colliderHalfW = obj.w / 2,
                        colliderHalfH = obj.h / 2,
                        entityHitboxCenterX = this.hitbox.x + this.hitbox.w / 2,
                        entityHitboxCenterY = this.hitbox.y + this.hitbox.h / 2,
                        colliderCenterX = obj.x + obj.w / 2,
                        colliderCenterY = obj.y + obj.h / 2,
                        
                        diffX = entityHitboxCenterX - colliderCenterX,
                        diffY = entityHitboxCenterY - colliderCenterY,
                        
                        minXDist = entityHitboxHalfW + colliderHalfW,
                        minYDist = entityHitboxHalfH + colliderHalfH,
                        
                        depthX = diffX > 0 ? minXDist - diffX : -minXDist - diffX,
                        depthY = diffY > 0 ? minYDist - diffY : -minYDist - diffY;
                        if (depthX != 0 && depthY != 0) {
                            if (Math.abs(depthX) < Math.abs(depthY)) {
                                return depthX > 0 ? "left" : "right";
                            } else {
                                return depthY > 0 ? "top" : "bottom";
                            }
                        } else return false;
                } else return false;
            }
            startAnimation() {
                this.animationInterval = setInterval(() => {
                    if (this.spriteIndex >= 3) Game.coinAnimationDirection = -1;
                    else if (this.spriteIndex <= 1) {
                        Game.coinAnimationDirection = 1;
                        this.stopAnimation();
                    }
                    this.sprite = sprites.tiles.coins.coin[this.spriteIndex];
                    this.spriteIndex += Game.coinAnimationDirection;
                }, 1000 / Game.fps * 9);
            }
            stopAnimation() {
                clearInterval(this.animationInterval)
                if (!this.collected) setTimeout(() => this.startAnimation(), 1000 / Game.fps * 18)
            }
            
            // Used to spawn the physical mushroom into the game and float it out of the tile
            spawn() {
                if (this.spawned) return true;
                //this.spawned = true;
                let floatHeight = 16;
                //for loop
                //increment y value over 2 seconds
                //Game.fps/2000
                //Game.items.push(this);
                Game.drawAsset(this);
                setInterval(() => {
                    if (this.y <= this.spawnY - floatHeight) {
                        clearInterval();
                        this.spawned = true;
                        this.canBeCollected = true;
                        this.hitbox.y = this.y + this.hitboxOffsets.y
                        return true;
                    };
                    this.y -= Game.fps / 600;
                }, Game.fps / 2000);
                return true;
            }

            /*
                function to check collision of item
                    use entity collision checker (unsure about variables, may have to create separate function for items)
                    if collision, give mario the ability and remove the item from memory to stop it from checking/drawing anything
                    if no collision, request animation from of function
                alternative:
                    do all above but instead of animation frame, use setInterval in a variable and clear it if collision=true
            */
        }
        
        class Coin extends Item {
            constructor(x, y, dynamic = false) {
                super(x, y);
                this.w = 16;
                this.h = 16;
                this.spriteIndex = 1;
                this.sprite = sprites.tiles.coins.coin[this.spriteIndex];
                this.palette = sprites.colours.coins[Game.worlds[Game.currentWorld][Game.currentLevel].location]
                this.value = Game.pointValues.coin;
                this.startAnimation();
            }
        }
        
        class Mushroom extends Item {
            constructor(x, y) {
                super(x, y, 2, 0, 12, 16);
                this.sprite = sprites.items.mushroom;
                let level = Game.worlds;
                this.palette = sprites.colours.items["overworld"];
                this.w = 16;
                this.h = 16;
                this.spawnY = this.y;
                this.spawned = false;
                this.speed = mario.physics.groundPhysics.walk.maxSpeed / 2;
                this.velocityY = 0;
                this.gravity = mario.physics.jumpPhysics.lower.fallingGravity / 2;
                this.collisions = {
                    left: false,
                    right: false,
                    top: false,
                    bottom: false
                }
            }

            // Method to move mushroom once spawned
            move() {
                // move mushroom at same speed as mario's max walk velocity
                /*
                    Method:
                        check if mushroom colliding with any tile on left/right
                        if yes invert velocity and speed
                        move mushroom
                */
                if (!this.collected) {
                    /*
                        For mushroom collision, use a smaller hitbox for mario
                        use regular size for tiles and such
                    */
                    this.x += this.speed;
                    this.velocityY += this.gravity;
                    this.y += this.velocityY;
                    let level = Game.worlds[Game.currentWorld][Game.currentLevel],
                        isBelow = false;
                    level.largeHitboxes.forEach(hb => {
                        let side = this.checkTileCollision(hb);
                        if (side == "left" && !this.collisions.left) {
                            this.collisions.left = true;
                            this.speed *= - 1;
                            this.x = hb.x + hb.w - this.hitboxOffsets.x;
                        }
                        if (side == "right" && !this.collisions.right) {
                            this.collisions.right = true;
                            this.speed *= - 1;
                            this.x = hb.x - this.w + this.hitboxOffsets.x;
                        }
                        if (side == "bottom" && !this.collisions.bottom) {
                            this.collisions.bottom = true;
                            this.y = hb.y - this.h + this.hitboxOffsets.y;
                            this.velocityY = 0;
                        }
                        this.hasTileBelow = this.checkIfBelow(hb);
                        if (this.hasTileBelow) {
                            isBelow = true;
                            this.y = hb.y - this.hitbox.h;
                        }
                        Game.log(this.hasTileBelow)
                    })
                    level.tiles.forEach(row => row.forEach(tile => {
                        let side = this.checkTileCollision(tile);
                        if (side == "left" && !this.collisions.left) {
                            this.collisions.left = true;
                            this.speed *= -1;
                            this.x = tile.x + tile.w - this.hitboxOffsets.x;
                        }
                        if (side == "right" && !this.collisions.right) {
                            this.collisions.right = true;
                            this.speed *= -1;
                            this.x = tile.x - this.w; 
                        }
                        if (side == "bottom" && !this.collisions.bottom) {
                            this.collisions.bottom = true;
                            this.y = tile.y - this.h + this.hitboxOffsets.y;
                            this.velocityY = 0;
                        }
                        this.hasTileBelow = this.checkIfBelow(tile);
                        if (this.hasTileBelow) {
                            isBelow = true;
                            this.y = tile.y - this.hitbox.h;
                        }
                    }))
                    if (isBelow) {
                        this.velocityY = 0;
                        this.gravity = 0;
                        this.hasTileBelow = true;
                    } else {
                        this.gravity = mario.physics.jumpPhysics.lower.fallingGravity / 2;
                    }
                }
                this.hitbox.x = this.x + this.hitboxOffsets.x;
                this.hitbox.y = this.y + this.hitboxOffsets.y;
                this.collisions = {
                    left: false,
                    right: false,
                    top: false,
                    bottom: false
                }
            }

            // Method to make mushrooms bounce when tile below is hit by mario
            bounce(tile) {
                if (tile)
                    if (this.checkIfTouching(tile)) {
                        let entSide = mario.checkCollisionSide(tile);
                        this.y ++
                        let itemSide = this.checkTileCollision(tile);
                        this.y --
                        if (entSide == "top" && itemSide == "bottom") {
                            //here is where would check which side both item and mario are on
                            /*
                                hold "left"/"right" for both item and mario
                            */
                            itemSide = this.hitbox.x + (this.hitbox.w / 2) < tile.x + (tile.w / 2) ? "left" : "right";
                            entSide = this.hitbox.x + (this.hitbox.w / 2) < tile.x + (tile.w / 2) ? "left" : "right";
                            // If item speed is positive. Allows the item to move the opposite way
                            if (this.speed > 0)
                            // Compares the sides that the entity and item are on, to determine whether to change the item's direction
                            if (
                                (itemSide == "left" && entSide == "right") ||
                                (itemSide == "right" && entSide == "left")
                            ) {
                                this.speed *= - 1;
                            }
                            //mushroom jump is 1 tile high
                            //length of time is about 1 second
                            this.velocityY = - 4.5
                        }
                    }
            }
        }
        
        class Flower extends Item {
            constructor(x, y) {
                super (x, y);
                this.sprite = {
                    head: sprites.items.flower.head.mario,
                    stem: sprites.items.flower.stem
                };
                this.palette = sprites.colours.items[Game.worlds[Game.currentWorld][Game.currentLevel].location];

            }
            /*
                function render each tile individually as they use different colour schemes
            */
            draw() {
                let originalFlowerY = this.y,
                    head = this.sprite.head,
                    stem = this.sprite.stem;
                this.sprite = head;
                Game.drawAsset(this);
                this.y += this.sprite.length * 16;
                this.sprite = stem;
                Game.drawAsset(this);
                this.sprite = {
                    head: head,
                    stem: stem
                };
                this.y = originalFlowerY;
            }
        }
        
        class ExtraLife extends Mushroom {
            constructor(x, y) {
                super(x, y);
                this.sprite = sprites.items.extraLife;
                this.palette = sprites.colours.items;
                this.value = Game.pointValues.powerUp;
                this.w = 16;
                this.h = 16;
            }
        }
        
        class Tile { // Main class for tiles
            constructor(sprite, x, y, validCollisionSides, breakable, contents = 0, canCheckBelow = false, invisible) {
                this.sprite = sprite,
                this.isBroken = false;
                this.breakable = breakable;
                this.x = x;
                this.y = y;
                this.w = 16;
                this.h = 16;
                // this is to make the tile only allow certain collisions on certain sides and stops mario from colliding with the wrong sides of tiles that he shouldnt
                // 0 for none, 1 for wall, 2 for floor, 3 for left corner (allows left side collision), 4 for right corner (allows right side collision)
                this.validCollisionSides = Game.collisionCombos[validCollisionSides];
                this.canCheckBelow = canCheckBelow;
                this.contents = contents; //coin is 1, mushroom 2, flower 3, star 4, vine 5
                this.usedInLargeHitbox = false;
                this.invisible = invisible;

                // This is where the items are spawned
                switch (this.contents) {
                    case 1: // Coin

                        // Give player coin + points
                        Game.coins ++
                        Game.totalPoints += Game.pointValues.coin;

                        // animate coin above tile
                        let coin = new Coin(this.x, this.y, true);
                        this.contents = coin;
                        return null;
                    case 2: // Mushroom
                        let mushroom = new Mushroom(this.x, this.y, Game.pointValues.powerUp);
                        Game.items.push(mushroom);
                        this.contents = mushroom;
                        return null;
                    case 3: // Flower
                        let flower = new Flower(this.x, this.y);
                        Game.items.push(flower);
                        this.contents = flower;
                        return null;
                    case 4: // Star
                        let star = new Star(this.x, this.y);
                        Game.items.push(star);
                        this.contents = star;
                        return null;
                    case 5: // Vine
                        // Vine may have to have extra attribute pointing to which extra section of the level to travel to
                        let vine = new Vine(this.x, this.y);
                        this.contents = vine;
                        return null;
                }
            }

            draw() {Game.drawAsset(this)}
        }
        
        /*class Camera {
            constructor() {
                this.x = 0;
                this.y = 0;
                this.width = 2048;
                this.height = 400;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            update() {
                // Center the camera on the player, but only move to the right
                const desiredX = mario.x + mario.hitboxOffsets.w / 2 - this.canvasWidth / 2;
                const desiredY = mario.y + mario.hitboxOffsets.h / 2 - this.canvasHeight / 2;

                // Ensure the camera only moves to the right
                if (desiredX > this.x) {
                    this.x = desiredX;
                }

                // Ensure the camera doesn't move out of the world bounds
                if (this.x < 0) this.x = 0;
                if (this.y < 0) this.y = 0;
                if (this.x + this.canvasWidth > this.width) this.x = this.width - this.canvasWidth;
                if (this.y + this.canvasHeight > this.height) this.y = this.height - this.canvasHeight;
            }

            apply(ctx) {
                ctx.setTransform(1, 0, 0, 1, -this.x, -this.y);
            }
        }*/

        class Camera {
            constructor(x, y, width, height, canvasWidth, canvasHeight) {
                this.x = 0;
                this.y = 0;
                this.width = width;
                this.height = height;
                this.canvasWidth = canvasWidth;
                this.canvasHeight = canvasHeight;
            }

            update() {

                // Center the camera on the player
                this.x = Math.floor(mario.x + mario.w / 2 - this.canvasWidth / 2);
                this.y = Math.floor(mario.y + mario.h / 2 - this.canvasHeight / 2);

                // Ensure the camera doesn't move out of the world bounds
                if (this.x < 0) this.x = 0;
                if (this.y < 0) this.y = 0;
                if (this.x + this.canvasWidth > this.width) this.x = this.width - this.canvasWidth;
                if (this.y + this.canvasHeight > this.height) this.y = this.height - this.canvasHeight;
            }

            apply() {
                canvas.setTransform(1, 0, 0, 1, -this.x, -this.y);
            }
        }

        class Level {
            constructor(tiles, tileList, location, entities, background) {
                //both background and tilemap are a grid of tiles 15x15 and will be in exactly the same format except the background won't be tangible
                //figure out level generation and creation, then sort out entities and stuff, then introduce the background (should require very little actual code to implement)
                this.tiles = tiles;
                this.tileList = tileList;
                this.location = location;
                this.entities = entities;
                this.background = background;
                this.largeHitboxes = [];
                this.items = [];
                for (let rowIndex = 0; rowIndex < this.tiles.length; rowIndex ++) {
                    for (let columnIndex = 0; columnIndex < this.tiles[rowIndex].length; columnIndex ++) {
                        if (this.tiles[rowIndex][columnIndex]) {
                            //                                           |               sprite                             |             x           |          y           |          validCollisionSides        |                    breakable                       |
                            this.tiles[rowIndex][columnIndex] = new Tile(this.tileList[this.tiles[rowIndex][columnIndex][0]], columnIndex * Game.block, rowIndex * Game.block, this.tiles[rowIndex][columnIndex][1], this.tiles[rowIndex][columnIndex][2] ? true : false, this.tiles[rowIndex][columnIndex][3] ? this.tiles[rowIndex][columnIndex][3] : 0);
                        }
                    }
                }
                this.createLargeHitboxes();
            }
            createLargeHitboxes() {
                /*
                    to auto-generate large hitboxes:
                        get coords of first tile
                        set new large hitbox to the tiles coords
                        check if there are any tiles adjacent to that tile on each side (only needs to be right/bottom side)
                        if yes, increase width / height to add that tile and check the next index

                            note:   might need to figure out a way to check if new hitbox will run over other tiles/ parts of the level that will mess up the level
                                    so will only do hitboxes 1 tile thick
                        if no, move to next side
                        if no extra tiles, keep hitbox as single tile and move to next tile
                        repeat process for every index until all hitboxes created

                            note: may have to make horizontal hitboxes slightly thinner in order to allow player to hit tiles

                        (this step isn't 100% necessary as far as I know)
                        check if any hitboxes overlap and if so, remove relevant number of tile spaces in order to clear the overlap
                    
                    will also need to create a function that allows the hitbox to be split when a tile is broken
                    steps to do so (when tile is hit): (these steps are only for horizontal hiboxes, but process is very similar for vertical hitboxes)
                        check if tile has been broken
                        if no, do nothing
                        if yes:
                            get index of broken tile and tile on the left and right
                            check if tile exists in left and right index
                            shorten original hitbox to exclude all tiles past the broken tile and save the width removed
                            create new hitbox at the tile next to broken tile
                            give hitbox width of removed tiles (so that the loop doesn't have to start again to check for tiles)
                */
                let tiles = this.tiles;
                this.largeHitboxes = [];
                for (let tileIndexY = 0; tileIndexY < tiles.length; tileIndexY ++) {
                    for (let tileIndexX = 0; tileIndexX < tiles[tileIndexY].length; tileIndexX ++) {
                        let row = tiles[tileIndexY];
                        let currentTile = row[tileIndexX];
                        if (currentTile && !currentTile.invisible) {
                            this.tiles[tileIndexY][tileIndexX].usedInLargeHitbox = true;
                            // Valid collision sides: left=0, right=1, bottom=2, top=3
                            let newHitbox = {
                                x: currentTile.x,
                                y: currentTile.y,
                                w: currentTile.w,
                                h: currentTile.h //possibly minus 5 if hitbox needs to be thinner than tiles to allow tiles to be hit
                            }
                            // Checking if tiles exist to the right of the current tile
                            // Running through the row adding tiles to hitbox until no tile in index
                            for (let addingTileIndex = tileIndexX + 1; addingTileIndex < row.length; addingTileIndex ++) {
                                let nextTile = row[addingTileIndex];
                                if (nextTile && !nextTile.usedInLargeHitbox) {
                                    this.tiles[tileIndexY][addingTileIndex].usedInLargeHitbox = true;
                                    newHitbox.w += Game.block;
                                } else {
                                    this.largeHitboxes.push(newHitbox);
                                    break;
                                }
                            }

                            if (newHitbox.w == 16)

                            // Checking tile below current tile
                            if (tiles[tileIndexY + 1]) {
                                if (tiles[tileIndexY + 1][tileIndexX])

                                // Runnning through the column adding tiles to hitbox until no tile in index
                                for (let addingTileIndex = tileIndexY + 1; addingTileIndex < tiles.length; addingTileIndex ++) {
                                    let nextTile = tiles[addingTileIndex][tileIndexX];
                                    if (nextTile)
                                    if (!nextTile.usedInLargeHitbox) {
                                        this.tiles[addingTileIndex][tileIndexX].usedInLargeHitbox = true;
                                        newHitbox.h += Game.block;
                                    } else break;
                                    else break;
                                }
                            }
                            if (newHitbox.w > 16 || newHitbox.h > 16) this.largeHitboxes.push(newHitbox);
                        }
                    }
                }

                // changing all tile usedInLargeHitbox attribute to false for next largeHitbox iteration
                for (let tileIndexY = 0; tileIndexY < tiles.length; tileIndexY ++) {
                    for (let tileIndexX = 0; tileIndexX < tiles[tileIndexY].length; tileIndexX ++) {
                        if (tiles[tileIndexY][tileIndexX] instanceof Tile) tiles[tileIndexY][tileIndexX].usedInLargeHitbox = false;
                    }
                }

                // Removing any hitbox that is the size of a single tile
                for (let largeHitboxIndex = 0; largeHitboxIndex < this.largeHitboxes.length; largeHitboxIndex ++) {
                    let hitbox = this.largeHitboxes[largeHitboxIndex];
                    if (hitbox.w <= 16 && hitbox.h <= 16) this.largeHitboxes[largeHitboxIndex] = "";
                }
            }
        }

        //tilesets that use different tiles from different sets should be assigned in a list to ensure they can still be used

        // Function that can pre-render tiles and should be used to be saved in variables
        function preRenderTile(tile, palette) {
            const offscreenCanvas = document.createElement('canvas');
            const canvas = offscreenCanvas.getContext('2d');
            offscreenCanvas.width = 16;
            offscreenCanvas.height = 16;
            offscreenCanvas.style.border = "none";
            for (let y = 0; y < 16; y ++) {
                for (let x = 0; x < 16; x ++) {
                    if (tile[y][x] > -1) {
                        let index = tile[y][x];
                        canvas.beginPath();
                        canvas.fillStyle = palette[index];
                        canvas.fillRect(x, y, 1, 1);
                    }
                }
            }
            return offscreenCanvas;
        }
        Game.drawAsset = (asset) => {
            let assetX = asset.x,
                assetY = asset.y,
                sprite = asset.sprite;
            for (let y = 0; y < sprite.length; y ++) {
                for (let x = 0; x < sprite[y].length; x ++) {
                    if (sprite[y][x] > -1) {
                        let index = sprite[y][x];
                        canvas.beginPath();
                        canvas.fillStyle = asset.palette[index];
                        canvas.fillRect(Math.floor(assetX) + x, Math.floor(assetY) + y, 1, 1);
                    }
                }
            }
        }

        // Function to find the longest nested array
        Game.getLongestLow = (arr) => {
            return arr.reduce((longest, current) => {
                return current.length > longest.length ? current : longest;
            }, []);
        };
        Game.updateLevel = () => {
            Game.level = Game.worlds[Game.currentWorld][Game.currentLevel];
        }
        /*
            use indexing in new Level() that gets the block class and creates it where new Tile() is above

            instead of multiple tile classes, perhaps use 1 tile class and use attributes in the use tile section of the new level 
            that defines what the block does, if it can be broken, if it drops something, etc.
        */
        
        function initGame() {
            // Initialize game elements
            Game.setResolution();
            camera = new Camera(0, 0, 2048, 400, canvasElem.width, canvasElem.height); // Adjust world dimensions accordingly
        }

        const   canvasWidth = parseInt(canvasElem.getAttribute("width")),
                canvasHeight = parseInt(canvasElem.getAttribute("height"));
        let mario = new Mario(201, 200),
            camera = new Camera;
        // Event listeners for mario movement
        document.addEventListener("keydown", (e) => {
            if (e.key == "a" || e.key == "A" || e.key == "ArrowLeft") {if (!mario.crouching) mario.keys.left = true; mario.movementFromCrouch.left = true; mario.lastMovementX = "left";}
            if (e.key == "d" || e.key == "D" || e.key == "ArrowRight") {if (!mario.crouching) mario.keys.right = true; mario.movementFromCrouch.right = true; mario.lastMovementX = "right";}
            if (e.key == "w" || e.key == "W" || e.key == "ArrowUp" || e.key == " ") mario.keys.up = true;
            if (e.key == "s" || e.key == "S" || e.key == "ArrowDown") {mario.keys.down = true; mario.crouch(); if (!mario.crouching && !mario.jumping) mario.y += 8;}
            if (e.key == "Shift") mario.keys.sprint = true;
        })
        document.addEventListener("keyup", (e) => {
            if (e.key == "a" || e.key == "A" || e.key == "ArrowLeft") {mario.keys.left = false; mario.movementFromCrouch.left = false;}
            if (e.key == "d" || e.key == "D" || e.key == "ArrowRight") {mario.keys.right = false; mario.movementFromCrouch.right = false;}
            if (e.key == "w" || e.key == "W" || e.key == "ArrowUp" || e.key == " ") {mario.keys.up = false; mario.holdingJumpButton = false;}
            if (e.key == "s" || e.key == "S" || e.key == "ArrowDown") {mario.keys.down = false; mario.standUp(); if (mario.size == 2) mario.y -= 8;}
            if (e.key == "Shift") mario.keys.sprint = false;
        })
        // Adding levels to worlds and worlds to game
        //create level class to store 
        //hold whatever variables (levels, chunks, tiles, etc) for referencing any part of the level inside the function
        Game.worlds = {
            1: {// World 1
                //this may need to be in a separate JS file (probably just put worlds into a separate file)
                1: new Level(
                    [ //tiles will be drawn row by row
                        /*
                            index and meaning:
                            1: sprite index
                            2: valid collision side index
                            3: breakable value
                            4: contents
                            5: canCheckBelow
                        */
                        /*
                            new way for tilemap:
                                instead of indexes, just use a name like "brick" or "question"
                        */
                        [ , , , , [1, 11], , [4, 0], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], , , , , , [2, 0, 0, 0] , , , , , , ,  [2, 0, 1]],
                        [ , , , , [2, 11], , , , , , , [2, 0, 0, 0], [2, 0, 0, 2], [2, 0, 1], [2, 0, 1], [2, 0, 1], [2, 0, 1]],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], ],
                        [ , , , , [2, 11], , , , , , /*[2, 0]*/, , , , , , [2,1], ],
                        [ , , , , [2, 0], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], [4, 13, 1], ],
                    ],
                    //list for tiles used in the level
                    /*List of all tiles used in level*/
                    [
                        /*
                            For tiles that use multiple sprites,
                            set interval in the tile class as an attribute to make them change their tile and colour (if necessary)
                            and stop the interval when the tile shouldn't change as well as setting it to a specific tile that it needs to be stationary on after interval is cleared
                        */
                        /*
                            Create Loop wherein at the start of each level, all possible variants of each tile are created.
                            holds each tile in a separate list with each variant as an index within the list
                            tilemap will need an extra value telling which tile variant to use

                            alternatively, use the regular tiles, but have a separate array of collision combinations, using the second value in the tilemap to determine which combination is to be used
                            for example,    using [0, 0] tells to use stairbrick with no collision
                                            using [0, 16] tells to use stairbrick with all collision
                            ther should be 16 possible combinations as there are 2 possible values per index and 4 indexes
                        */
                        // Blocks used
                        preRenderTile(sprites.tiles.groundAndStone.stairBrick, sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.crackedBrick, sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.coins.question[1], sprites.colours.coins.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.brick1, sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.emptyBrick, sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[1], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[2], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[3], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[4], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[5], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[6], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[7], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[8], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[9], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.pipe[10], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.flagpole[1], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.tiles.pipesAndScenery.flagpole[2], sprites.colours.pipesAndScenery.overworld),
                        preRenderTile(sprites.dynamicObjects.flags.pole, sprites.colours.items.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[1], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[2], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[3], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[4], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[5], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[6], sprites.colours.groundAndStone.overworld),
                        preRenderTile(sprites.tiles.groundAndStone.castleTiles[7], sprites.colours.groundAndStone.overworld),
                        // Items used
                        // Background tiles used
                    ],
                    "overworld",
                ),
            }
        };

        let testShroom = new Mushroom(100, 100);
        testShroom.spawn();
        // Game loop stuff
        Game.loop = setInterval(() => {
            let level = Game.worlds[Game.currentWorld][Game.currentLevel];
            Game.clearCanvas();
            canvas.beginPath();
            canvas.fillStyle = "rgb(148, 138, 255)";
            canvas.fillRect(0, 0, canvasElem.getAttribute("width"), canvasElem.getAttribute("height"));
            
            // Handles collision for large hitboxes to stop player phasing through tiles
            //mario.largeLevelHitboxCollision();
            
            // Move player
            mario.move();

            // Handles item collision
            Game.items.forEach(item => {
                if ((item instanceof Mushroom || item instanceof ExtraLife) && item.canBeCollected) {
                    if (!(
                        mario.hitbox.x > item.hitbox.x + item.hitbox.w ||
                        mario.hitbox.x + mario.hitbox.w < item.hitbox.x ||
                        mario.hitbox.y > item.hitbox.y + item.hitbox.h ||
                        mario.hitbox.y + mario.hitbox.h < item.hitbox.y
                    )) {
                        Game.items.splice(Game.items.indexOf(item), 1);
                        mario.changeSize();
                    } else if (item instanceof Mushroom || item instanceof ExtraLife /*|| item instanceof Star*/) item.move();
                }
            })
            
            // Update the camera position based on the player
            camera.update();

            // Apply camera transformation
            camera.apply();

            // Draw the game world and player
            //mario.y --
            mario.draw(); //unsure if code above and below makes mario's sprite go up by 1 pixel
            //mario.y ++

            canvas.beginPath();
            canvas.fillStyle = "white";
            canvas.fillRect(mario.hitbox.x, mario.hitbox.y + mario.hitbox.h - 2, mario.hitbox.w / 2, 2);
            canvas.beginPath();
            canvas.fillStyle = "black";
            canvas.fillRect(mario.hitbox.x + mario.hitbox.w / 2, mario.hitbox.y + mario.hitbox.h - 2, mario.hitbox.w / 2, 2);

            // Draws hitbox
            mario.drawHitbox("green");

            // Draws items in Game.items as well as hitboxes (if desired)
            Game.items.forEach(item => {
                Game.drawAsset(item);
                canvas.beginPath(); canvas.fillStyle = "blue"; canvas.fillRect(item.hitbox.x, item.hitbox.y, item.hitbox.w, item.hitbox.h);
            });
            

            // Draws tiles
            level.tiles.forEach(row => {for (let i = 0; i < row.length; i ++) if (row[i] instanceof Tile && !row[i].isBroken) canvas.drawImage(row[i].sprite, row[i].x, row[i].y)});
            //level.largeHitboxes.forEach(hitbox => {canvas.beginPath();canvas.fillStyle = "red";canvas.fillRect(hitbox.x + 1, hitbox.y + 1, hitbox.w - 2, hitbox.h - 2)});

            // Get the longest nested array (will be used for calculating level length)
            const longestRow = Game.getLongestLow(level.tiles);
            //debug.innerHTML = `jump: ${mario.jumping} <br> vY: ${mario.velocityY} <br> grav: ${mario.gravity}`

        }, 1000 / Game.fps);
        initGame();
        //mario.changeSize();
        //Game.items.push(new Coin(30, 30))
        //Game.items.push(new Coin(250,150))
        //will need to be called at the start of every level
        /*
            new collision check formula:
                put all levls into 16x16 grid for collision checking
                check which grid mario is within (using manipulated version of current collision algorithm)
                check all tiles within that grid
        */
    </script>
</body>
</html>